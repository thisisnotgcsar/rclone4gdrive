#!/bin/sh

# rclone4gdrive
# Purpose: Manage rclone timer/service operations for Google Drive synchronization.
# Features:
#   - Provides status and restart commands for rclone systemd units.
#   - Supports dry-run bisync operations.
#   - Installs and enables systemd user units from the daemons/ directory.
#   - 'init' command sets up gdrive remote, ensures $HOME/gdrive exists, and copies the script directory for system-wide or user use.

show_help() {
  cat <<EOF
Usage: $0 <command>

Commands:
  status         Show a compact summary of rclone.timer and the last 10 lines of the rclone.service journal
  restart        Restart rclone.timer and show the updated status
  dry-run        Run rclone bisync in dry-run mode
  sync-daemons   Install service/timer unit files from daemons/ into ~/.config/systemd/user, reload and enable/start them
  init           Initialize gdrive remote, ensure \$HOME/gdrive exists, and copy the script directory for deployment
  help, -h, --help  Show this help message
EOF
}

# --- Utility functions ---

status_cmd() {
  echo "== rclone.timer (compact) =="
  systemctl --user status rclone.timer ||
    echo "Timer unit rclone.timer not found or systemctl unavailable."

  echo
  echo "== rclone.service (last 10 lines) =="
  # Show only last 10 journal lines for quick inspection
  journalctl --user -u rclone.service -n 10 --no-pager 2>/dev/null || {
    echo "No journal entries found for rclone.service or journalctl unavailable."
  }
}

restart_cmd() {
  echo "Restarting rclone.timer..."
  if systemctl --user restart rclone.timer 2>/dev/null; then
    echo "Timer restarted successfully."
  else
    echo "Failed to restart rclone.timer (check permissions or unit existence)."
  fi
  echo "Starting rclone.service immediately..."
  if systemctl --user start rclone.service 2>/dev/null; then
    echo "Service started successfully."
  else
    echo "Failed to start rclone.service (check permissions or unit existence)."
  fi
}

dry_run_cmd() {
  echo "Running rclone bisync in dry-run mode..."
  /usr/bin/rclone bisync gdrive: "$HOME/gdrive" --min-size 0 --log-level=ERROR --dry-run
}

sync_daemons_cmd() {
  SCRIPT_DIR=`dirname "$0"`
  DAEMONS_DIR="$SCRIPT_DIR/daemons"
  TARGET_DIR="$HOME/.config/systemd/user"

  if [ ! -d "$DAEMONS_DIR" ]; then
    echo "Daemons directory not found: $DAEMONS_DIR"
    return 1
  fi

  mkdir -p "$TARGET_DIR"

  # Find .service and .timer files
  units=""
  for f in "$DAEMONS_DIR"/*.service "$DAEMONS_DIR"/*.timer; do
    [ -e "$f" ] && units="$units $f"
  done

  if [ -z "$units" ]; then
    echo "No .service or .timer files found in $DAEMONS_DIR"
    return 1
  fi

  echo "Copying unit(s) to $TARGET_DIR..."
  for f in $units; do
    cp -a "$f" "$TARGET_DIR/" || {
      echo "Failed to copy: $f"
    }
  done

  echo "Reloading user systemd daemon..."
  systemctl --user daemon-reload 2>/dev/null || {
    echo "Warning: daemon-reload failed or systemctl --user unavailable in this environment."
  }

  echo "Enabling and starting timer units only..."
  for f in $units; do
    unit=`basename "$f"`
    case "$unit" in
      *.timer)
        systemctl --user enable --now "$unit" 2>/dev/null && \
          echo "Enabled & started: $unit" || \
          echo "Could not enable/start: $unit (you may need to run this from your user session)"
        ;;
    esac
  done
}

init_cmd() {
  if [ -d "$HOME/gdrive" ] && rclone listremotes | grep -q '^gdrive:'; then
    echo "$HOME/gdrive exists and 'gdrive' remote found in rclone. Skipping rclone initialization."
  else
    echo "Initializing gdrive rclone instance under $HOME/gdrive..."
    mkdir -p "$HOME/gdrive"
    rclone config create gdrive drive || { echo "rclone config failed. Aborting init."; exit 1; }
  fi

  SCRIPT_DIR=`dirname "$0"`
  TARGET_BIN="$HOME/bin/"
  mkdir -p "$TARGET_BIN"
  echo "Copying $SCRIPT_DIR to $TARGET_BIN ..."
  cp -a "$SCRIPT_DIR" "$TARGET_BIN"

  BASHRC="$HOME/.bashrc"
  PATH_LINE='export PATH="$HOME/bin/rclone4gdrive:$PATH"'
  grep -Fxq "$PATH_LINE" "$BASHRC" || {
    echo "$PATH_LINE" >> "$BASHRC"
    echo "Added $PATH_LINE to $BASHRC. Run: source $BASHRC to update your PATH."
  }

  sync_daemons_cmd
  restart_cmd
}

# --- Main argument parsing ---

if [ $# -lt 1 ]; then
  show_help
  exit 1
fi

COMMAND=$1
COMMAND=`echo "$COMMAND" | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`

case "$COMMAND" in
  status)
    status_cmd
    ;;

  restart)
    restart_cmd
    ;;

  dry-run)
    dry_run_cmd
    ;;

  sync-daemons)
    sync_daemons_cmd
    ;;

  init)
    init_cmd
    ;;

  help|-h|--help)
    show_help
    ;;

  *)
    echo "Unknown command: $COMMAND"
    show_help
    exit 1
    ;;
esac